---
description: Rules for TypeScript usage and general code style
globs: "*.ts,*.tsx,*.js,*.jsx"
alwaysApply: true
---
# TypeScript and Code Style Rules

## Type Definitions
- Always use explicit types for function parameters and return values
- Use interfaces for object shapes
- Use type aliases for complex types
- Use generics for reusable components and functions
- Avoid `any` type - use `unknown` if type is truly unknown

## Naming Conventions
- Use PascalCase for class names, interfaces, and type aliases
- Use camelCase for variables, functions, and methods
- Use UPPER_CASE for constants
- Use descriptive names that convey purpose

## Functions
- Prefer arrow functions for callbacks and methods
- Use function declarations for top-level functions
- Keep functions small and focused on a single responsibility
- Document complex functions with JSDoc comments

## Error Handling
- Use try/catch blocks for error-prone operations
- Provide meaningful error messages
- Consider using custom error classes for specific error types

## Imports and Exports
- Use named exports for multiple exports from a file
- Use default exports for main component/class of a file
- Group imports by type (React, third-party, local)
- Use absolute imports for project modules

## Example
```typescript
interface User {
  id: string;
  username: string;
  email: string;
  isActive: boolean;
}

type UserResponse = {
  status: boolean;
  data: User | null;
  message?: string;
};

/**
 * Fetches a user by ID
 * @param userId The ID of the user to fetch
 * @returns A promise that resolves to the user response
 */
const fetchUser = async (userId: string): Promise<UserResponse> => {
  try {
    const response = await api.get<UserResponse>(`users/${userId}`);
    return response.data;
  } catch (error) {
    console.error(`Failed to fetch user ${userId}:`, error);
    return {
      status: false,
      data: null,
      message: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}; 